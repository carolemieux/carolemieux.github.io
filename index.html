<!DOCTYPE html>
<html>
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<head>
<link rel="stylesheet" type="text/css" href="main.css">
</head>

<body>

<div class="main">

<header>
<img src="caro.jpg" width=250 alt="Caroline Lemieux">
<br> <br> <br> <br>
<h1>Caroline Lemieux</h1>
PhD Candidate
<br />
<a href="http://www.berkeley.edu/"> University of California Berkeley</a><br />
Department of <a href="http://www.eecs.berkeley.edu/">Computer Science</a>
<br />
Email: clemieux<span style="display:none">bots-gotta-get-smarter-than-this</span><span>@</span><span style="display:none">its-really-not-that-hard</span><span>cs.berkeley.edu</span>
<br />
Twitter: <a href="https://twitter.com/cestlemieux">@cestlemieux</a>
<br />
Github: <a href="https://github.com/carolemieux">carolemieux</a>
<br />
<!-- Teaching: <a href="61a.html">Spring 2019 CS 61A</a>
<br /> -->
</header>

<h2>About</h2>
<div class="hbar">
</div> 
<section class="inner">
<p>I am a fourth year Ph.D. candidate at the University of California, Berkeley, advised by <a href="http://people.eecs.berkeley.edu/~ksen">Koushik Sen</a>. 
My research interests centre around improving, or helping developers to improve, 
the correctness, reliability, and understanding of software systems. I am particularly
interested in developing automated methods for engineering tasks such as testing, debugging, and
comprehension, 
and lean towards work with strong empirical aspects (i.e. requiring large-scale data analysis). 
</p>
<p>
This interest is a defining thread through my current and past research projects. My current research into automated testing, particularly fuzz testing, aims to produce tools which test programs as effectively as possible with as little user input as possible. In Summer 2018, I interned at Google, where I built large-scale static analysis to automatically generate <a href="https://llvm.org/docs/LibFuzzer.html#fuzz-target">fuzz targets</a>.  In Summer 2017 I was a research intern in the <a href="https://www.microsoft.com/en-us/research/project/tools-for-software-engineers/">Tools for Software Engineers</a> group at Microsoft, working on automating detection of anomolous errors in the distributed build system CloudBuild.
At UBC, I worked
with <a href="http://www.cs.ubc.ca/~bestchai/">Ivan Beschastnikh</a> on automated specification mining 
tools. 
</p>
<p>In May 2016 I received my B.Sc. (in 
Combined Honours Computer Science and Mathematics) at the University of British Columbia, and was awarded the Governor General's Silver Medal for highest standing in the graduating class of the Faculty of Science.
</p>

<p> I was awarded a Google PhD Fellowship in Programming Technologies and Software Engineering for 2019.</p>
</section>

<h2>Projects</h2>
<div class="hbar">
</div> 
<br>
<section class="inner">
    <h3> Current </h3>
</section>
<table class="inner">

<tr>
<td style = "width:25%" align="center">
<img src="autopandas_logo.png" alt="AutoPandas" width="200">
</td>
<td align="justify">
Modern Python APIs are complex and very difficult to learn. Novice users could ask their API questions on StackOverflow, but the answer might be slow to arrive or unpersonalized... enter AutoPandas. AutoPandas is a programming-by-example synthesis engine for the Python API pandas, in particular for its dataframe transformations. To handle the complex space of API programs, AutoPandas uses a novel <a href="https://github.com/rbavishi/atlas">neural-backed generator</a> approach to synthesizing programs in the pandas API. You can try out AutoPandas live at <a href="https://autopandas.io">autopandas.io</a>.
</td></tr>

<tr>
<td style = "width:25%" align="center">
<img src="fuzzfact_logo.png" alt="FuzzFactory" width="250">
</td>
<td align="justify">
 <a href="https://github.com/rohanpadhye/FuzzFactory">FuzzFactory</a> is an extension of AFL that generalizes coverage-guided fuzzing to domain-specific testing goals. FuzzFactory allows users to guide the fuzzer's search process without having to modify the core search algorithm. FuzzFactory's key abstraction is that of waypoints: intermediate inputs that are saved during the fuzzing loop. For example, PerfFuzz saves inputs that increase loop execution counts, a magic-byte fuzzer may save inputs that have partially correct magic bytes, or a directed fuzzer may save inputs that are more likely to exercise a program point of interest.

</td></tr>

<tr>
<td style = "width:25%" align="center">
<img src="zest_logo.svg" alt="Zest" height="160">
</td>
<td align="justify">
Binary-level mutational fuzzing excels at exercising the syntactic (parsing) phase of programs, but produces few valid inputs that exercise deeper stages of the program. <a href="https://github.com/pholser/junit-quickcheck">QuickCheck-style</a> random testing allows us to test programs with random generators of highly-structured inputs, but does not use program feedback to bias its input generation. <a href="https://github.com/rohanpadhye/jqf">Zest</a>, the default front-end of our <a href="https://github.com/rohanpadhye/jqf">JQF</a> platform, leverages (1) QuickCheck-style generators to generate only syntactically valid inputs, and (2) program coverage and validity feedback to generate inputs which explore deep parts of the program.  
</td></tr>
<tr>
<td style = "width:25%" align="center">
<img src="perffuzz-logo.png" alt="PerfFuzz" height="140">
</td>
<td align="justify">
Performance problems in software can arise unexpectedly when programs are provided with inputs that exhibit pathological behavior. But how can we find these inputs in the first place? Given a program and at least one seed input, <a href="https://github.com/carolemieux/perffuzz">PerfFuzz</a> automatically generates inputs that exercise pathological behavior across program locations, without any domain knowledge. 
</td></tr>
<tr>
<td style = "width:25%">
<img src="FairFuzz-logo.png" alt="FairFuzz" width="250">
</td>
<td align="justify">
 <a href= "https://github.com/carolemieux/afl-rb">FairFuzz</a> is a fuzzer built on top of 
 <a href=http://lcamtuf.coredump.cx/afl/>AFL</a> which targets rare branches to achieve faster program coverage. FairFuzz achieves this by (1) selectively mutating inputs which exercise branches hit by few fuzz-tester generated inputs and (2) using a <i>mutation mask</i> to restrict mutations of these inputs to the parts which can be mutated while still hitting the branch of interest. On our benchmarks, FairFuzz achieves program coverage than AFL or AFLFast, and has a particular advantage on programs with <i>highly nested structure</i>.
</td></tr>
</table>

<br>
<section class="inner">
    <h3> Past </h3>
</section>

<table class="inner">
<tr>
<td style = "width:25%">
<img src="texada-pic.jpg" alt="Texada" width="250">
</td>
<td align="justify">
I am the main developer of the <a href= "https://bitbucket.org/bestchai/texada">Texada</a> tool,
which mines linear temporal logic (LTL) relationships of arbitrary length and complexity from textual logs.
Texada takes as input a log of traces and a property type expressed in LTL and outputs
instantiations of this property types with log events which hold on the entire log. Texada
also supports confidence and support thresholds to allow for mining on imperfect or
incomplete logs. 
</td>
</tr>
<tr> 
<td>
<img src="quarry-pic.PNG" alt="Quarry" width="250">
</td>
<td align="justify">
I also built the Quarry tool. Quarry interfaces data predicates with temporal
invariants in order to extract data-temporal invariants of 
arbitrary length and complexity from program execution. Quarry 
mines relationships between Daikon-style data predicates specified 
in linear temporal logic (LTL). Quarry uses Daikon for data predicate 
inference and Texada for inference of temporal invariants. 
</td>
</tr>
<td style = "width:25%">
<img src="coursera-pic.jpg" alt="Introduction to Systematic Program Design" width="250">
</td>
<td align="justify">
I worked on one of UBC's first computer science MOOCs, Introduction to Systematic Program
Design, while the course was still hosted on Coursera.
I worked on both MOOC offerings, focusing mostly on video lecture development, but also participating in TA
tasks like replying to students on forums and composing peer-graded projects. The video lectures from
the Coursera offering were used in CPSC 110, UBC's introductory computer science course, and are available
for viewing <a href= "https://www.youtube.com/channel/UC7dEjIUwSxSNcW4PqNRQW8w">here</a>. </td></tr>
</table>


<h2>Publications</h2>
<div class="hbar">
</div> 
<div class="inner">
<ul>

<li> Sameer Reddy, <b>Caroline Lemieux</b>, Rohan Padhye, Koushik Sen. Quickly Generating Diverse Valid Test Inputs with Reinforcement Learning.
<i>To appear in ICSE 2020.</i>
</li>

<li> Rohan Bavishi, <b>Caroline Lemieux</b>, Roy Fox, Koushik Sen, Ion Stoica. AutoPandas: Neural-Backed Generators for Program Synthesis. 
<i> OOPSLA 2019</i>.
<a href="autopandas_oopsla19.pdf">pdf</a>.
</li>

<li> Rohan Padhye, <b>Caroline Lemieux</b>, Koushik Sen, Laurent Simon, Hayawardh Vijayakumar. FuzzFactory: Domain-Specific Fuzzing with Waypoints. 
<i> OOPSLA 2019</i>.
<a href="fuzzfactory_oopsla19.pdf">pdf</a>.
</li>

<li>
Domagoj Babic, Stefan Bucur, Yaohui Chen, Franjo Ivancic, Tim King, Markus Kusano, <b>Caroline Lemieux</b>, László Szekeres, Wei Wang. FUDGE: Fuzz Driver Generation at Scale. In <i>Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE 2019</i> (Industry Track). <b>ACM/SIGSOFT Best Paper Award of ESEC/FSE Industry Track</b>.
<a href="https://ai.google/research/pubs/pub48314">pdf</a>.
</li>

<li> Rohan Padhye, <b>Caroline Lemieux</b>, Koushik Sen. JQF: Coverage-Guided Property-Based Testing in Java. In <i>Proceedings of the 28th International Symposium on Software Testing and Analysis, ISSTA 2019</i> (Tool Demo Track). <b>ACM/SIGSOFT Tool Demonstration Award</b>. <a href="jqf_issta19.pdf">pdf</a>.</li>

<li> Rohan Padhye, <b>Caroline Lemieux</b>, Koushik Sen, Mike Papadakis, Yves Le Traon. Semantic Fuzzing with Zest. In <i>Proceedings of the 28th International Symposium on Software Testing and Analysis, ISSTA 2019</i>. <b>ACM/SIGSOFT Distinguished Artifact Award</b>. <a href="zest_issta19.pdf">pdf</a>.</li>

<li> Rohan Bavishi, <b>Caroline Lemieux</b>, Neel Kant, Roy Fox, Koushik Sen, Ion Stoica. Neural Inference of API Functions from Input–Output Examples. In <a href="http://mlforsystems.org"><i>Workshop on ML for Systems at NeurIPS 2018</i></a>. <a href="autopandas_mlforsys18.pdf">pdf</a>, <a href="autopandas_mlforsys18_slides.pdf">slides</a>.</li>

<li><b>Caroline Lemieux</b> and Koushik Sen. FairFuzz: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage. In <i>Proceedings of the 33rd IEEE/ACM International Conference on Automated Software Engineering, ASE 2018</i>.  <a href="fairfuzz-ase18.pdf">pdf</a>, <a href="fairfuzz_ase18_slides.pdf">slides</a>.</li>
<li><b>Caroline Lemieux</b>, Rohan Padhye, Koushik Sen, and Dawn Song. PerfFuzz: Automatically Generating Pathological Inputs. In <i>Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA 2018</i>. <b>ACM/SIGSOFT Distinguished Paper Award</b>. <a href="perffuzz-issta2018.pdf">pdf</a>, <a href="perffuzz_issta18_final_slides.pdf">slides</a>.</li>
<li><b>Caroline Lemieux</b>, Dennis Park and Ivan Beschastnikh. General LTL Specification Mining. In <i>Proceedings of the 30th International Conference on Automated Software Engineering, ASE 2015</i>, Lincoln, USA. 
    <a href="texada-ase15_final.pdf">pdf</a>,
    <a href="ASE15-texada-slides.pdf">slides</a>.</li>
<li><b>Caroline Lemieux</b> and Ivan Beschastnikh. Investigating Program Behavior Using the Texada LTL Specifications Miner. In <i>Proceedings of the 30th International Conference on Automated Software Engineering, ASE 2015</i>, Lincoln, USA. (Tool Demonstration Track).
    <a href="texada_ase15_demos_final.pdf">pdf</a>.</li> 
<li><b>Caroline Lemieux</b>. Mining Temporal Properties of Data Invariants. In <i>Proceedings of the 37th International Conference on Software Engineering, ICSE 2015</i>, Florence, Italy. (ACM SRC Research Abstract). 
    <a href="icse15-quarry-src-abstract.pdf">pdf</a>.</li>
</ul>
</div>



<h2>Posters</h2>
<div class="hbar">
</div> 
<div class="inner">
<ul>
<li>
Validity Fuzzing and Parametric Generators for Effective Random Testing.
Poster at ICSE 2019, Montréal, Canada. <a href="zest_icse19_poster.pdf">pdf</a></li>
</li>
<li>PerfFuzz: Automatically Generating Pathological Inputs. Poster at ISSTA 2018, Amsterdam, Netherlands.  
    <a href="perffuzz_poster_issta18.pdf">pdf</a></li>
<li>Mining Temporal Relationships Between Data Invariants. Poster in SRC at ICSE 2015, Florence, Italy.  
    <a href="quarrypostertemp_v4.pdf">pdf</a></li>
</ul>
</div>

<h2>Mentoring</h2>
<div class="hbar">
</div> 
<div class="inner">
<p>	
I've been lucky to work with some great students while at Berkeley.
</p>
<ul> 
<li><a href="http://linkedin.com/in/sameerreddy">Sameer Reddy</a>: worked on RLCheck.</li> 
</ul>
</div>

<h2>Service</h2>
<div class="hbar">
</div> 
<div class="inner">
<ul>
<li><a href="https://www.computer.org/csdl/journal/ts">TSE 2019</a></li>
<li><a href="https://onlinelibrary.wiley.com/journal/10991689">STVR 2019</a></li>
<li><a href="https://icst2020.info/track/icst-2020-Poster-Track">ICST 2020 Posters</a></li>
<li><a href="https://2019.icse-conferences.org/track/icse-2019-Demonstrations">ICSE 2019 Demos</a></li>
<li><a href="https://www.icse2018.org/track/icse-2018-Posters">ICSE 2018 Posters</a></li>
<li>Subreviewer: ICSE 2017 NIER, PLDI 2017, ASPLOS 2018, PLDI 2018, CAV 2018, ICST 2020</li>
</ul>
</div>

<h2>Funding</h2>
<div class="hbar">
</div> 
<div class="inner">
<p>
I am thankful to have received funding from Google,
<a href="http://www.nserc-crsng.gc.ca/">NSERC</a>, <a href="https://nsf.gov/">NSF</a>, <a href="http://www.ubc.ca">UBC</a>, and <a href="http://www.berkeley.edu/">UCB</a>
to support my research.
</p>
</div>
<script type="text/javascript">

<!--
var m = "Last updated: " + document.lastModified;
var p = m.length-8;
document.writeln('<p id="update">');
document.write(m.substring(p, 0));
document.writeln("</p>");
 -->
</script>
</body>
</html>
